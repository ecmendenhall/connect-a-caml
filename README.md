To build and run the test suite:
```
ocamlbuild <File>.native <File>Test.native -pkg oUnit -use-ocamlfind && ./FileTest.native
```

## A Tour of OCaml
OCaml was invented in France and named after a stubborn land mammal.

### Types
OCaml is typed, but you won't see many type declarations. The compiler infers types from values and
optional signatures. New types are declared with the `type` keyword:

```
type gamepiece = X | O
```

This binds a type name (`gamepiece`) to a type constructor (`X` or `O`).
Types constructors can also take arguments:

```
type square = Empty | Full of gamepiece
type gamestate = Win of gamepiece | Draw | Pending
```

Here, a square is either `Empty`, `Full X`, or `Full O`.

Complex and nested types can get weird, but they're relatively easy to decode by
reading in reverse. For instance, a board has type `square list list`, which is a list of
lists of squares, like `[[Empty; Empty; Full X;]]`.

### Lists
Lists are semicolon-separated: `[1; 2; 3; 4; 5]`.

### Interfaces
Like C, interfaces are specified in separate files from implementations. Interface files
end in `.mli` and describe names and type signatures for each function in a module. They can
be written by hand, or generated by a friendly OCaml compiler.

For example, the `IO` interface looks like this:

```
module type IO =
  sig
    val clear_screen: unit -> unit
    val get_input : unit -> string
    val show_board : Types.square list list -> unit
    val show_message : string -> Types.message -> unit
  end
```
You'll find the `unit` type hanging out around functions with side effects. A function that returns
nothing returns `unit`, so here `clear_screen` takes no arguments and returns no value, `get_input`
takes no args but returns a string, and `show_board` and `show_message` both take things and display
them without returning values.

An interesting thing: Module types are inferred based on the interface files OCaml finds on the
project build path. Any module that provides these four functions will be recognized as type `IO`,
and substitutable for any other.

This example is a pure interface (there is no corresponding 'IO.ml' file), but every OCaml file is
a module, and every module has an interface.

### Pattern matching

Here's a function that takes a winning row and maps it to a
`Pending` or `Win` game state. Each pattern is tried in succession
(much like Lisp `cond` clauses), and the function returns the value
of the first guard that matches. Here, it's matching against the first
element in a winning row, which will

```
let row_state row =
  if (row_has_win row) then match List.hd row with
    | Empty  -> Pending
    | Full O -> Win O
    | Full X -> Win X
  else
    Pending
```

Notice that the first guard should never match, since a winning row should not
contain an `Empty` square. The OCaml compiler flags incomplete matches with a warning,
so it's included here only to placate it.

Even though pattern matching is totally rad, there are times when it's a _faux pas_ (French
intended). Thus this:

```
let player_message symbol =
  let suffix = " be a [h]uman or [c]omputer?" in
  if symbol = X then
    IO.show_message ("Will Player X" ^ suffix) (Prompt X)
  else
    IO.show_message ("Will Player O" ^ suffix) (Prompt O)
```

is preferred to this:

```
let player_message symbol =
  let suffix = " be a [h]uman or [c]omputer?" in
  match symbol with
    | X -> IO.show_message ("Will Player X" ^ suffix) (Prompt X)
    | O -> IO.show_message ("Will Player O" ^ suffix) (Prompt O)
```

and this:

```
if valid_size size then size else get_size ()
```

to this:

```
match valid_size size with
  | true  -> size
  | false -> get_size ()
```


### Destructuring
The `::` symbol is the cons operator, which works just like `cons` in Lisp:

```
# 1 :: [];;
- : int list = [1]

# 1 :: 2 :: [];;
- : int list = [1; 2]
```

It's also used for destructuring patterns. Here, the first case checks
against the empty list, the second case extracts the first element, checks
it against `Full O` and ignores the rest, and the third case ignores the
first element and recurs on the rest of the list:

```
let rec contains_O row = match row with
  | []           -> false
  | Full O :: _  -> true
  | _ :: xs      -> contains_O xs
```

### Functors
Seriously, "functors?" That's what I thought, too. Functors are functions that take modules as
parameters, plug those modules into a template, and return a new module _parameterized_ by those modules.
Which is all just a confusing way to say "functors do dependency injection."

For instance, I wanted to keep my `Game` module decoupled from I/O and player implementations, so I
use the following functor, that takes a module of type `IO` and two modules of type `PLAYER` as parameters.
(`ALL_CAPS` is the style for module types).

```
open IOInterface
open IOInterface
open PlayerInterface
open Engine

module GameFunctor (IO : IO) (PlayerX : PLAYER) (PlayerO : PLAYER) =
  struct
    open Types
    include Types

    let play_round turn board = match turn with
      | X -> PlayerX.next_move board
      | O -> PlayerO.next_move board

    let game_over_message state =
      let prefix = "Game over: " in
        match state with
          | Draw  -> IO.show_message (prefix ^ "it's a draw.") Info
          | Win X -> IO.show_message (prefix ^ "Player X wins.") (Prompt X)
          | Win O -> IO.show_message (prefix ^ "Player O wins.") (Prompt O)
          | _     -> ()

    let rec game_loop turn board =
      IO.show_board board;
      let next_turn = match turn with X -> O | O -> X in
        match Engine.board_state board with
          | Pending  -> game_loop next_turn (play_round next_turn board)
          | end_type -> game_over_message end_type
  end;;
```

elsewhere, I can construct a `Game` module dynamically and call its functions like any other:

```
let module Game = GameFunctor (JumbotronIO) (NeuralNetPlayer) (EvolutionaryPlayer)

let _ = Game.game_loop X (Board.empty_board 3)
```

### Type conversion
Idiomatic OCaml uses function names like `int_of_string` and `float_of_int` for casting one
type to another.
